mean(c(1))
mean(c(1, 2))
mean(c(1, NAN))
mean(c(1, NaN))
mean(c(1, NULL))
mean(c(1, NA))
mean(c(1,2,NULL))
mean(c(1,2,NA))
mean(c(1,2,"NA"))
mean(c(1,2,NaN))
NULL/5
NULL/5
NULL/1.52324
NULL*1.52324
print(NULL)
length(NULL/5)
length(NULL/5)
length(0/5)
length(NULL/5)
rawresInputList <- createRawresInput("run111_FOCEI_8_retry533_LAPLACE.mod", paramsToCompare = c("THETA1","OMEGA(2,2)"), resol = 12, lims1 = c(-10.363,-10.373), lims2 = c(0.00795018,0.00795045))
lala <- "C:\Program Files (x86)\WANdisco\Subversion\Apache2\bin;C:\Program Files (x86)\WANdisco\Subversion;C:\RBuildTools\3.1\bin;C:\RBuildTools\3.1\gcc-4.6.3\bin;C:\Perl64\site\bin;C:\Perl64\bin;C:\Program Files\Common Files\Microsoft Shared\Windows Live;C:\Program Files (x86)\Common Files\Microsoft Shared\Windows Live;C:\Program Files (x86)\R\R-3.0.0\library\rJava\jre\bin\client;C:\Program Files (x86)\R\R-3.0.0\library\rJava\jre\bin;C:\Program Files (x86)\R\R-3.0.0\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\Program Files (x86)\PuTTY\;C:\Program Files\TortoiseSVN\bin;C:\Program Files (x86)\Windows Live\Shared;C:\Program Files (x86)\Kaspersky Lab\Kaspersky Endpoint Security 10 for Windows\;C:\nm73g64\run\;C:\Program Files (x86)\MiKTeX 2.9\miktex\bin\;C:\Program Files\wkhtmltopdf\bin;C:\nm73g64\run;C:\ProgramData\Monolix\Monolix432s\bin\;C:\Program Files (x86)\Skype\Phone\"
install.packages("mlxR")
library(mlxR)
myModel <- inlineModel("
[LONGITUDINAL]
input = {ka, V, Cl}
EQUATION:
C = pkmodel(ka,V,Cl)
[INDIVIDUAL]
input = {ka_pop, V_pop, Cl_pop, omega_ka, omega_V, omega_Cl}
DEFINITION:
ka = {distribution=lognormal, reference=ka_pop, sd=omega_ka}
V = {distribution=lognormal, reference=V_pop, sd=omega_V }
Cl = {distribution=lognormal, reference=Cl_pop, sd=omega_Cl}
")
N=2000
pop.param <- c(
ka_pop = 1, omega_ka = 0.5,
V_pop = 10, omega_V = 0.4,
Cl_pop = 1, omega_Cl = 0.3)
res <- simulx(model = myModel,
parameter = pop.param,
treatment = list(time=0, amount=100),
group = list(size=N, level=
'
individual
'
),
output = list(name=
'
C
'
, time=seq(0,24,by=0.1)))
cols = NULL
length(cols)
rawresPath <- C:/Users/hnyberg/Dropbox/Doktorandsaker/PrecondProject/LikelihoodSurface/plotlyTestJonsson/para_retries_160214_152105/raw_results_new_run111_FOCEI_8_retry533_LAPLACE_origin.csv"
rawresPath <- "C:/Users/hnyberg/Dropbox/Doktorandsaker/PrecondProject/LikelihoodSurface/plotlyTestJonsson/para_retries_160214_152105/raw_results_new_run111_FOCEI_8_retry533_LAPLACE_origin.csv"
rawres <- read.csv(rawresPath, header = TRUE)
rawres
head(rawres)
cols <- c("ofv")
read.csv(rawresPath, header = TRUE)[cols]
head(read.csv(rawresPath, header = TRUE)[cols])
head(read.csv(rawresPath, header = TRUE)[cols][1])
head(read.csv(rawresPath, header = TRUE)[cols][-1])
rawres$ofv
head(rawres$ofv)
head(rawres$ofv[-1])
cols
cols <- c()
cols
length(cols)
class(cols)
cols <- c("", "")
length(cols)
cols <- c("", "")
class(cols)
length(cols)
if(length(cols) > 0){
rawres <- read.csv(rawresPath, header = TRUE, ...)[cols]
}else{
rawres <- read.csv(rawresPath, header = TRUE, ...)
}
if(length(cols) > 0){
rawres <- read.csv(rawresPath, header = TRUE)[cols]
}else{
rawres <- read.csv(rawresPath, header = TRUE)
}
lala <- c("THEAT1", "OMEGA(2,2)")
cols <- c(lala, "ofv")
if(length(cols) > 0){
rawres <- read.csv(rawresPath, header = TRUE)[cols]
}else{
rawres <- read.csv(rawresPath, header = TRUE)
}
rawres <- read.csv(rawresPath, header = TRUE)[cols]
cols
cols[1]
lala <- c("THETA1", "OMEGA(2,2)")
cols <- c(lala, "ofv")
cols
rawres <- read.csv(rawresPath, header = TRUE)[cols]
names(read.csv(rawresPath, header = TRUE))
names(read.csv(rawresPath, header = TRUE, check.names = FALSE))
cols
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE, ...)[cols]
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE)[cols]
head(rawres)
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE, skip = 1)[cols]
cols
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE, skip = 1)[cols]
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE, skip = 1)
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE, skip = 1)[cols]
cols
head(rawres)
head(rawres)[-1]
head(rawres)[,-1]
head(rawres)[-1,]
rawres[2:4]
rawres[,2:4]
rawres[2:4,]
rawres[3:4,]
rawres[4:5,]
rawres[[4:5,]]
rawres[[4:5]]
rawres[[1]]
rawres[["ofv"]]
rawres[[2]]
head(rawres)
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE
)[cols]
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE
)[cols]
head(rawres)
head(rawres[-1])
head(rawres[,-1])
head(rawres[-1,])
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE)[cols][-1,]
head(rawres)
rowsTo Skip <- 1:skipRows
rowsToSkip <- 1:skipRows
skipRows = 0
rowsTo Skip <- 1:skipRows
rowsToSkip <- 1:skipRows
rowsToSkip
1:skipRows
skipRows
skipRows <- 1
1:skipRows
skipRows <- 5
1:skipRows
rawres
head(rawres)
rawres <- read.csv(rawresPath, header = TRUE, check.names
)[cols]
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE
)[cols]
head(rawres)
rowsToSkip
skipRows
skipRows <- 1
if(skipRows > 0){
rawres <- rawres[-(1:skipRows),]
}
skipRows
head(rawres)
ofvVector <- rawres["ofv"]
ofvVector
class(ofvVector)
head(ofvVector)
ofvVector <- as.vector(rawres["ofv"])
head(ofvVector)
class(ofvVector)
class(ofvVector[1])
head(ofvVector[1])
rawres <- read.csv(rawresPath, header = TRUE, check.names = FALSE)[cols]
head(rawres)
if(skipRows > 0){
rawres <- rawres[-(1:skipRows),]
}
head(rawres)
rawres["ofv"]
head(rawres["ofv"])
head(rawres[["ofv"]])
rawres[["ofv"]]
head(rawres[["ofv"]])
class(rawres[["ofv"]])
paramsToCompare[2]
paramsToCompare <- c("THETA1", "OMEGA(2,2)")
paramsToCompare[2]
rawres[[paramsToCompare[2]]]
xParamValsOutput <- unique(rawres[[paramsToCompare[2]]])
xParamValsOutput
source('C:/Users/hnyberg/Dropbox/Doktorandsaker/precondproject/Scripts/dismount/R/plotSurface.R', echo=TRUE)
print("Creating Plotly plot")
#' plotSurface
#'
#' Plots a surface using Plotly and returns the URL
#'
#' @param plotlyUsername Plotly online user name. Not needed if environment variables already set. See plotly instructions.
#' @param plotlyKey Plotly online key. Not needed if environment variables already set. See plotly instructions.
#' @param modFilePath Model file to use. The called function createRawresInput assumes that there is an ext file with the same base file name.
#' @param paramsToCompare Parameters to compare. A vector of two parameter names following the NONMEM ext file standard names. Default is c("THETA1", "THETA2"). Model file parameter labels will be removed.
#' @param resol Resolution on each axis. Default is 10 and will use 10^2 = 100 sets of parameter values, NONMEM runs, and ofv values to create the plot.
#' @param ofvScaling If true OFVs are scaled to between zero and one. Default is FALSE.
#' @param cleanLevel PsN clean script will be run on the parallel retries folder. See psn_clean documentation. Default is 4, the highest cleaning level.
#' @param origVals Whether or not to plot the original model final estimate as a point in the plot.
#' @param ... Further options to createRawresInput
#'
#' @export
plotSurface <- function(plotlyUsername, plotlyKey, modFilePath,
paramsToCompare = c("Param1", "Param2"),
resol = 10, local = FALSE, ofvScaling = FALSE,
slurm_partition = "standard", cleanLevel = 4,
plotOrigVals = FALSE, ...){
require(plotly)
Sys.setenv("plotly_username" = plotlyUsername)
Sys.setenv("plotly_api_key" = plotlyKey)
print(paste("Preparing model file", modFilePath, "by removing commented out code and setting MAXEVALS"))
modFileOrig <- readLines(modFilePath)
modFile <- setMaxEvals(modFileOrig, 0)
modFile <- gsub("[[:space:]];.+", "", modFile)
newModFileName <- paste0("new_", basename(modFilePath))
writeLines(modFile, newModFileName)
print("Creating the rawres input file")
rawresInputList <- createRawresInput(modFilePath = modFilePath, paramsToCompare = paramsToCompare, resol = resol, ...)
print("Running Parallel retries")
dirName <- runParaRetries(newModFileName, rawres_input = rawresInputList[[1]], clean = 3,
slurm_partition = slurm_partition, local = local)
print("Parsing OFVs")
rawresPath <- findRawres(dirName)
rawres <- parseRawres(rawresPath, cols = c(paramsToCompare, "ofv"), skipRows = 1)
xParamValsInput <- rawresInputList[[2]]
xParamValsOutput <- order(unique(rawres[[paramsToCompare[1]]]))
yParamValsInput <- rawresInputList[[3]]
yParamValsOutput <- order(unique(rawres[[paramsToCompare[2]]]))
# Checking that input and output parameter values are the same (NONMEM does change them sometimes)
sapply(seq_along(xParamValsInput), function(x){
if(!identical(xParamValsInput[x], xParamValsOutput[x])){
paramMessage <- paste("Input and output values are different:\n",
"Input ", x, ":", xParamValsInput[x],
"Output ", x, ":", xParamValsOuput[x],
"Using output values")
print(paramMessage)
}
})
plotTitle <- paste0("\n<b>OFV Surface for ", modFilePath, "</b><br>", resol, "x", resol,
"resolution. Retries folder ", dirName)
print("Creating Plotly plot")
plotlyObj <- createPlotlyObj(ofvVector = rawres[["ofv"]],
xParamVals = xParamValsOutput,
yParamVals = yParamValsOutput,
origVals = rawresInputList[[4]],
plotOrigVals = plotOrigVals,
paramsToCompare = paramsToCompare,
ofvScaling = ofvScaling,
plotTitle = plotTitle)
plotly_POST(plotlyObj, fileopt = "new")
# Clean up using the psn_clean
print(paste("Cleaning up", dirName, "with level =", cleanLevel))
runPsnClean(dirName, level = cleanLevel, interact = FALSE)
return(list(plotlyObj, dirName))
}
#' Run parallel retries
#'
#' This is a wrapper function for parallel_retries in PsN
#' @param modFileName The model to run parallel retries on. Only one permitted.
#' @param paraRetriesCmd Command or path used to run parallel retries. Default is "parallel_retries" which assumes the PsN directory is on the PATH.
#' @param dir The directory to run in. Defaults to "para_retries_<date>_<time>".
#' @param clean The post-run clean-up level. Exactly wrapping the PsN option. Defaults to 2.
#' @param threads The number of threads to use. Exactly wrapping the PsN option. Defaults to 100.
#' @param min_retries The number of retries to run. Exactly wrapping the PsN option. Defaults to 1
#'
#' runParaRetries()
#'
#' @export
#'
runParaRetries <- function(modFileName, paraRetriesCmd = "parallel_retries",
dir = paste0("para_retries_", format(Sys.time(), "%y%m%d_%H%M%S")),
clean = 2, threads = 100, min_retries = 1, degree = 0.1,
slurm_partition = "standard", rawres_input = "", seed = format(Sys.time(), "%Y%m%d"),
local = FALSE, nm_output = NULL){
# Test that degree is not outside its bounds
if(degree <= 0 || degree >= 1){
print("Degree setting must be between 0 and 1")
return(NULL)
# If it is ok, set the degree option
}else{
perturbation <- paste0(" -degree=", degree)
}
# Set nm_output if there is any
if(length(nm_output) > 0){
extraNMOutputs <- paste0(" -nm_output=", paste(nm_output, collapse = ","))
}else{
extraNMOutputs <- ""
}
partition <- paste0(" -slurm_partition=", slurm_partition)
# If there is a rawres input file supplied, and that file exists, use it and disregard min_retries.
# If there isn't one, use the min_retries setting
ifelse(file.exists(rawres_input),
retriesOrInput <- paste0(" -rawres_input=", rawres_input),
retriesOrInput <- paste0(" -min_retries=", min_retries))
# Create the command
cmd <- paste0(paraRetriesCmd, " ", modFileName, " -dir=", dir,
retriesOrInput, " -clean=", clean,
perturbation, " -threads=", threads, " -seed=",
seed, partition, extraNMOutputs)
# Print the command to command line
print(cmd)
# Run the command
system(cmd, intern=FALSE, wait=TRUE)
return(dir)
}
getwd()
setwd("C:/Users/hnyberg/Dropbox/Doktorandsaker/PrecondProject/Scripts/dismount")
library(roxygen2)
roxygenise()
roxygenise()
extFileName
dismountWD <- getwd()
setwd("C:/Users/hnyberg/Dropbox/Doktorandsaker/PrecondProject/LikelihoodSurface/plotlyTestJonsson")
extFileName <- "run111_FOCEI_8_retry533_FO_LAPLACE.ext"
if(!file.exists(extFileName)){
print("No .ext file found for this model. Please run it first")
break()
}
extFileDFList <- parseExtFile(extFileName)
# Get the last table in the ext file
extFileDF <- extFileDFList[[length(extFileDFList)]]
# Pick out the final parameter values row
paramVectorRow <- subset(extFileDF, ITERATION == -1e+9)
# Pick out the OBJ values and package it with the original values of paramsToCompare
origParamsAndOFV <- cbind(paramVectorRow[paramsToCompare],
paramVectorRow[length(paramVectorRow)])
# Ignoring the first and last column (Iteration and OBJ)
paramVectorFull <- paramVectorRow[2:(length(paramVectorRow)-1)]
extFileDFList <- parseExtFile(extFileName)
install_github("uppsalahenrik/dismount")
library(devtools)
install_github("uppsalahenrik/dismount")
library(dismount)
extFileDFList <- parseExtFile(extFileName)
# Get the last table in the ext file
extFileDF <- extFileDFList[[length(extFileDFList)]]
# Pick out the final parameter values row
paramVectorRow <- subset(extFileDF, ITERATION == -1e+9)
# Pick out the OBJ values and package it with the original values of paramsToCompare
origParamsAndOFV <- cbind(paramVectorRow[paramsToCompare],
paramVectorRow[length(paramVectorRow)])
# Ignoring the first and last column (Iteration and OBJ)
paramVectorFull <- paramVectorRow[2:(length(paramVectorRow)-1)]
paramVectorFull
abs(paramVectorFull)
paramVectorFull
absolute <- TRUE
paramVectorFull <- ifelse(absolute, abs(paramVectorFull), paramVectorFull)
paramVectorFull
paramVectorFull <- paramVectorRow[2:(length(paramVectorRow)-1)]
if(absolute){
paramVectorFull <- abs(paramVectorFull)
}
paramVectorFull
lims1
rawres[[paramsToCompare[2]]]
unique(rawres[[paramsToCompare[2]]
)
unique(rawres[[paramsToCompare[2]]])
order(unique(rawres[[paramsToCompare[2]]]))
unique(rawres[[paramsToCompare[2]]])
rawresInputList[[3]]
origParamsAndOFV
origParamsAndOFV[paramsToCompare]
abs(origParamsAndOFV[paramsToCompare])
origParamsAndOFV[paramsToCompare] <- abs(origParamsAndOFV[paramsToCompare])
origParamsAndOFV[paramsToCompare]
setwd(dismountWD)
roxygenise
roxygenise()
365/12
4/30.4
*7800
4/30.4*7800
0.13*7800
Sys.getenv("plotly_username")
Sys.setenv("plotly_username"="UppsalaHenrik")
Sys.setenv("plotly_api_key"="ja9b5copw1")
0.13*7800
Sys.getenv("plotly_username")
