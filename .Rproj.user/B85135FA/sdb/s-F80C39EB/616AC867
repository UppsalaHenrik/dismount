{
    "contents" : "#' Full workflow with parallel retries, result categorization and dismount/precond run\n#'\n#'\n#'\n#' @param modFileName The model file to use. Default is \"run83.mod\".\n#' @param retries The number of retries to run as part of the initial parallel retries.\n#'\n#' @author Henrik Bjug√•rd Nyberg - henrik.b.nyberg@@farmbio.uu.se\n#'\n\ndismountWorkflow <- function(modFileName, retries = 9){\n\n  userWD <- getwd()\n\n  #Set up folders for the workflow\n  dismountRunsDir <- \"dismountRuns\"\n  modFileNameNoExt <- fileSysSetup(modFileName, \"massDismount\", c(dismountRunsDir))\n\n  workflowWD <- getwd()\n\n  # Run initial para retries (wait = TRUE)\n  print(\"Running parallel retries\")\n  paraRetriesDirName <- runParaRetries(modFileName, min_retries = retries, degree = 0.99,\n                            slurm_partition = \"standard\", local = FALSE, nm_output = \"rmt\",\n                            seed = 20150806)\n\n  # Wait for the queue to have only the master job left\n  waitForSlurmQ(targetLength = 1)\n\n  # Find rawres file and parse it. Just in case there is more than one matched I take the first one.\n  rawresPath <- findRawres(paraRetriesDirName)\n  rawres <- parseRawres(rawresPath)\n\n  rawresNoNA <- subset(rawres, ofv != 'NA')\n\n  # Find the minimum OFV value to use as reference\n  minOfv <- min(rawresNoNA$ofv)\n\n  # List the retries that\n  overMinOfvRetries <-  subset(rawresNoNA, ofv > minOfv + 1)\n  nOverMinOfvRetries <- nrow(overMinOfvRetries)\n\n  # Print a message about the number of retries over\n  print(paste(\"After parallel retries with\", retries, \"samples,\",\n              nOverMinOfvRetries, \"samples were over minimum OFV by 1 or more\"))\n\n  # add retry number to rawres dataframe\n  retry <- rawresNoNA$model - 1\n  rawresNoNA <- cbind(retry, rawresNoNA)\n\n  # List the Retry model files for dismount runs\n  retryModFilePaths <- list.files(path = paraRetriesDirName, pattern = \"retry.+mod$\")\n\n  # Copy those files into the dismount runs directory\n  file.copy(paste0(paraRetriesDirName, \"/\", retryModFilePaths), dismountRunsDir)\n\n  # Set the dismount runs directory as WD\n  setwd(dismountRunsDir)\n\n  # Run dismount on the models\n  dismountDirList <- sapply(retryModFilePaths, runDismount)\n  # I've had issues with the runs not strting before I start the wait below, so here is a little initial wait\n  Sys.sleep(10)\n\n  # Wait for the queue to have only the master job left\n  waitForSlurmQ(targetLength = 1)\n\n  # Find and parse the rawres files, and then put them together\n  dismountRawresFiles <- list.files(recursive = TRUE)[grep(\"pert_init_est_modelfit/raw_results.csv\", list.files(recursive = TRUE))]\n  dismountRawresList <- lapply(dismountRawresFiles, parseRawres)\n  dismountRawres <- do.call(\"rbind\", dismountRawresList)\n\n  # I bind in the retry number as well\n  # This is a little dangerous as it assumes the order is the same...\n  # I could do this within the apply above instead, and parse the actual number...\n  dismountRawres <- cbind(retry[-1], dismountRawres)\n\n  # Pick out the\n  overMinOfvDismountRetries <- subset(dismountRawres, ofv > minOfv + 1)\n  nOverMinOfvDismountRetries <- nrow(overMinOfvDismountRetries)\n\n  # Print a message about the number of retries over\n  print(paste(\"After dismount on\", length(retryModFilePaths), \"samples,\",\n              nOverMinOfvDismountRetries, \"samples were over minimum OFV by 1 or more\"))\n\n  setwd(userWD)\n}\n\n\n\n\n\n\n\n\n\n# Below is some ancient code that was the starting point for the above. Please disregard\n\n\n\n\n\n\n\n\n\n\n# The below block of code was there for categorization, which I am now skipping.\n\n\n\n# Categorize retries, pick out runs with min success, cov fail and an ofv higher than minimum\n# These are potential saddle points\n#   minOfv <- min(rawresNoNA$ofv)\n#   covFailOverMLERawres <- subset(rawresNoNA, minimization_successful == 1 &\n#                                  covariance_step_successful == 0 &\n#                                  ofv > minOfv + 1)\n#\n#   # Pick out runs at minimum with min success and cov fail, These can probably be bettered with precond\n#   covFailAtMLERawres <-subset(rawresNoNA, minimization_successful == 1 &\n#                               covariance_step_successful == 0 &\n#                               ofv < minOfv + 1)\n#\n#\n#\n#   # Run dismount of all the models.\n#\n#   # list the model files\n#   retryModFileNames <- list.files(pattern = paste0(\"retry.+\\\\.mod\"))\n#\n#   # run dismount on them\n#   dismountDirs <- sapply(retryModFileNames, runDismount)\n#\n#   # Wait for the queue to be empty\n#   waitForSlurmQ(targetLength = 1)\n#\n#\n#\n#\n#   print(\"done... so far\")\n# parse isestimable files\n\n# If certain situation (error messages?), run precond\n\n# parse precond rawres file\n\n# Build new rawres with all the runs (hopefully they are now all at MLE)\n\n\n# Set back the working directory\n\n#\n#   # parse relevant lst files for saddle point covariance step error messages\n#   saddleRetriesList <- lapply(covFailOverMLERawres$retry, function(x){\n#\n#     lstFileName <- list.files(pattern = paste0(\"retry\", x, \".lst\"))\n#\n#     covMessages <- parseCovMessages(lstFileName)\n#\n#     # Look for the saddle point message and, if found, return x, the retry number\n#     if(grepl(\"R MATRIX ALGORITHMICALLY NON-POSITIVE-SEMIDEFINITE BUT NONSINGULAR\", covMessages)){\n#       return(x)\n#     }\n#\n#   # If the saddle point message isn't found, return NULL\n#   return(NULL)\n#   })\n#\n#   saddleRetries <- unlist(saddleRetriesList)\n#\n#   # Find the model files that correspond to the saddle point retries\n#   saddleModelFiles <- unlist(lapply(saddleRetries, function(x){\n#     list.files(pattern = paste0(\"retry\", x, \".mod\"))\n#   }))\n#\n#   # Run isestimable (dismount) on them\n#\n#   dismountDirs <- sapply(saddleModelFiles, runDismount)\n\n\n\n#\n#\n# read.csv()\n#\n# ofvLim <- min(rawres$ofv, na.rm = TRUE) + 1\n#\n# modNums <- rawres$model[rawres$minimization_successful == 1 &\n#                           rawres$covariance_step_successful == 0 &\n#                           rawres$ofv >= ofvLim]\n#\n# retryNums <- modNums - 1\n#\n#\n#\n# lstFiles <- getParaRetryFiles(path = \"./\", fileExt = \".lst\", retryNumsToParse = retryNums)\n#\n# covMessageList <- sapply(lstFiles, parseCovMessages)\n#\n#\n# list.files()[]\n#\n#\n# rMatFiles <- list.files()[grep(\"\\\\.rmt\", list.files())]\n#\n# rMatList <- lapply(rMatFiles, parseNonmemMat)\n#\n# rMatListNoZero <- lapply(lapply(rMatList, stripZeroRowsCols), '[[', 1)\n#\n# rMatEigenDecompList <- lapply(rMatListNoZero, eigen)\n#\n# lapply(rMatEigenDecompList, '[', \"values\").\n",
    "created" : 1439555004378.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3929180826",
    "id" : "616AC867",
    "lastKnownWriteTime" : 1440172620,
    "path" : "C:/Users/hnyberg/Dropbox/Doktorandsaker/PrecondProject/Scripts/dismount/R/dismountWorkflow.R",
    "project_path" : "R/dismountWorkflow.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}