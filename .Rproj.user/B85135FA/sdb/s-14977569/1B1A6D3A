{
    "contents" : "#\n# I don't think I'd be the most suitable to pilot this, but I might give in to pier pressure and ship in with some puns. To lighten up any stern faces I mean.\n#\n# I'm sure this project will see some hardship, and go through many oar deals...\n\ndismountWorkflow <- function(modFileName = \"run83.mod\", retries = 9){\n\n\nprint(\"Run para retries\")\n# Run initial para retries (wait = TRUE)\ndirName <- runParaRetries(modFileName, min_retries = retries, degree = 0.99,\n                          slurm_partition = \"standard\", local = FALSE, nm_output = \"rmt\",\n                          seed = 20150806)\n\n# Move into that directory\nsetwd(dirName)\n\n# Find rawres file and parse it. Just in case there is more than one matched I take the first one.\nrawresPath <- findRawres(\".\")\nrawres <- parseRawres(rawresPath)\n\nrawresNoNA <- subset(rawres, ofv != 'NA')\n\n# add retry number to rawres dataframe\nretry <- rawresNoNA$model - 1\nrawresNoNA <- cbind(retry, rawresNoNA)\n\n# Categorize retries, pick out runs with min success, cov fail and an ofv higher than minimum\n# These are potential saddle points\nminOfv <- min(rawresNoNA$ofv)\ncovFailOverMLERawres <- subset(rawresNoNA, minimization_successful == 1 &\n                               covariance_step_successful == 0 &\n                               ofv > minOfv + 1)\n\n# Pick out runs at minimum with min success and cov fail, These can probably be bettered with precond\ncovFailAtMLERawres <-subset(rawresNoNA, minimization_successful == 1 &\n                            covariance_step_successful == 0 &\n                            ofv < minOfv + 1)\n\n\n# parse relevant lst files for saddle point covariance step error messages\nsaddleRetriesList <- lapply(covFailOverMLERawres$retry, function(x){\n\n  lstFileName <- list.files(pattern = paste0(\"retry\", x, \".lst\"))\n\n  covMessages <- parseCovMessages(lstFileName)\n\n  # Look for the saddle point message and, if found, return x, the retry number\n  if(grepl(\"R MATRIX ALGORITHMICALLY NON-POSITIVE-SEMIDEFINITE BUT NONSINGULAR\", covMessages)){\n    return(x)\n  }\n\n  # If the saddle point message isn't found, return NULL\n  return(NULL)\n})\n\nsaddleRetries <- unlist(saddleRetriesList)\n\n# Find the model files that correspond to the saddle point retries\nsaddleModelFiles <- unlist(lapply(saddleRetries, function(x){\n    list.files(pattern = paste0(\"retry\", x, \".mod\"))\n  }))\n\n# Run isestimable (dismount) on them\n\ndismountDirs <- sapply(saddleModelFiles, runDismount)\n\n# Wait for the queue to be empty\nwaitForSlurmQ(targetLength = 1)\n\nprint(\"done... so far\")\n  # parse isestimable files\n\n# If certain situation (error messages?), run precond\n\n  # parse precond rawres file\n\n# Build new rawres with all the runs (hopefully they are now all at MLE)\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n#\n# read.csv()\n#\n# ofvLim <- min(rawres$ofv, na.rm = TRUE) + 1\n#\n# modNums <- rawres$model[rawres$minimization_successful == 1 &\n#                           rawres$covariance_step_successful == 0 &\n#                           rawres$ofv >= ofvLim]\n#\n# retryNums <- modNums - 1\n#\n#\n#\n# lstFiles <- getParaRetryFiles(path = \"./\", fileExt = \".lst\", retryNumsToParse = retryNums)\n#\n# covMessageList <- sapply(lstFiles, parseCovMessages)\n#\n#\n# list.files()[]\n#\n#\n# rMatFiles <- list.files()[grep(\"\\\\.rmt\", list.files())]\n#\n# rMatList <- lapply(rMatFiles, parseNonmemMat)\n#\n# rMatListNoZero <- lapply(lapply(rMatList, stripZeroRowsCols), '[[', 1)\n#\n# rMatEigenDecompList <- lapply(rMatListNoZero, eigen)\n#\n# lapply(rMatEigenDecompList, '[', \"values\")\n",
    "created" : 1438945002948.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1740616117",
    "id" : "1B1A6D3A",
    "lastKnownWriteTime" : 1438953592,
    "path" : "C:/Users/hnyberg/Dropbox/Doktorandsaker/PrecondProject/Scripts/dismount/R/dismountWorkflow.R",
    "project_path" : "R/dismountWorkflow.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}